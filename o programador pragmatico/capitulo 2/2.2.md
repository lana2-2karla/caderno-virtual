# ğŸ§© ORTOGONALIDADE (sem dor de cabeÃ§a)

## ğŸ“Œ â€œA ortogonalidade Ã© um conceito crÃ­ticoâ€¦â€

**TraduÃ§Ã£o humana:**
Ortogonalidade Ã© MUITO importante se vocÃª quer criar sistemas que:

* sejam fÃ¡ceis de **pensar**
* fÃ¡ceis de **construir**
* fÃ¡ceis de **testar**
* fÃ¡ceis de **mexer depois sem quebrar tudo**

ğŸ‘‰ Em outras palavras: sistemas que **nÃ£o dÃ£o medo de alterar**.

---

## ğŸ“Œ â€œMas raramente esse conceito Ã© ensinado diretamenteâ€¦â€

Aqui o autor estÃ¡ reclamando ğŸ˜…
Ele diz que:

* ninguÃ©m ensina â€œortogonalidadeâ€ de forma explÃ­cita
* ela aparece escondida em conceitos como:

  * modularizaÃ§Ã£o
  * camadas
  * boas prÃ¡ticas
  * separaÃ§Ã£o de responsabilidades

ğŸ‘‰ O erro Ã© nÃ£o dar nome ao conceito.
Quando vocÃª entende **o nome e a ideia**, vocÃª comeÃ§a a **usar de propÃ³sito**.

---

## ğŸ“Œ â€œQuando vocÃª aprender a aplicar o princÃ­pio da ortogonalidade diretamenteâ€¦â€

**Resumo:**
Quando vocÃª comeÃ§a a pensar conscientemente:

> â€œIsso aqui estÃ¡ independente do resto?â€

a qualidade do seu sistema **sobe instantaneamente** ğŸ“ˆ

Ã‰ tipo aprender a cozinhar sabendo *por que* cada ingrediente existe, e nÃ£o sÃ³ seguir receita.

---

# ğŸ“ O que Ã© ortogonalidade?

## ğŸ“Œ Origem na geometria

Duas linhas ortogonais formam um **Ã¢ngulo de 90Â°** (como X e Y no grÃ¡fico).

* Mexe no eixo X â¡ï¸ nada acontece no Y
* Mexe no eixo Y â¡ï¸ nada acontece no X

ğŸ‘‰ **IndependÃªncia total**

---

## ğŸ“Œ Em termos simples

> â€œMover uma coisa nÃ£o afeta a outraâ€

---

## ğŸ“Œ Em computaÃ§Ã£o

Aqui vem a definiÃ§Ã£o-chave:

> Duas coisas sÃ£o ortogonais quando **alteraÃ§Ãµes em uma nÃ£o afetam a outra**

### ğŸ§  Exemplo clÃ¡ssico:

* Interface do usuÃ¡rio (tela, botÃµes)
* Banco de dados

ğŸ‘‰ VocÃª deveria conseguir:

* trocar a tela sem mexer no banco
* trocar o banco sem mexer na tela

Se nÃ£o consegue, o sistema **nÃ£o Ã© ortogonal** ğŸ˜¬

---

# ğŸš Sistema NÃƒO ortogonal (o helicÃ³ptero do caos)

Essa histÃ³ria Ã© uma **metÃ¡fora gigante**.

### O que acontece?

VocÃª mexe **um controle**â€¦

* e afeta **todos os outros**
* aÃ­ tenta corrigirâ€¦
* e cria **mais problemas**
* vira um ciclo infinito de ajustes

ğŸ‘‰ Isso Ã© um sistema **nÃ£o ortogonal**

---

## ğŸ’» TraduÃ§Ã£o para software

Ã‰ aquele sistema onde:

* vocÃª muda um botÃ£o na tela
* quebra o backend
* corrige o backend
* quebra o relatÃ³rio
* corrige o relatÃ³rio
* quebra o login ğŸ˜­

VocÃª vira o piloto desesperado do helicÃ³ptero.

---

## ğŸ“Œ ConclusÃ£o do exemplo

> â€œOs controles do helicÃ³ptero sÃ£o decididamente nÃ£o ortogonais.â€

Ou seja:

* tudo depende de tudo
* nada Ã© previsÃ­vel
* controlar Ã© difÃ­cil
* errar Ã© fÃ¡cil

---

# âœ… Vantagens da ortogonalidade

## ğŸ“Œ â€œSistemas nÃ£o ortogonais sÃ£o mais difÃ­ceis de mudarâ€

Porque:

* nada Ã© isolado
* nÃ£o existe â€œconserto localâ€
* mexer em um ponto espalha problemas

---

## ğŸ’¡ DICA 13

### â€œElimine efeitos entre elementos nÃ£o relacionadosâ€

Essa frase vale ouro ğŸ’›

ğŸ‘‰ **Se duas coisas nÃ£o tÃªm relaÃ§Ã£o direta, elas NÃƒO deveriam se afetar.**

---

## ğŸ§± Componentes autossuficientes

O autor fala de componentes que:

* fazem **uma coisa bem definida**
* nÃ£o dependem do resto
* nÃ£o vazam comportamento

Isso se chama **coesÃ£o**.

### ğŸ³ Exemplo do dia a dia:

* Liquidificador â†’ sÃ³ bate
* Geladeira â†’ sÃ³ refrigera
* FogÃ£o â†’ sÃ³ esquenta

Imagine se:

* ligar o fogÃ£o desligasse a geladeira
* abrir a geladeira mudasse a potÃªncia do liquidificador

ğŸ‘ Caos total
ğŸ‘ EletrodomÃ©sticos sÃ£o ortogonais

---

# ğŸš€ Duas grandes vantagens

## 1ï¸âƒ£ Maior produtividade

### Por quÃª?

* MudanÃ§as sÃ£o **localizadas**
* Componentes pequenos sÃ£o:

  * mais fÃ¡ceis de criar
  * mais fÃ¡ceis de testar
  * mais fÃ¡ceis de entender

ğŸ‘‰ VocÃª cria, testa, confia e **segue a vida**.

---

### â™»ï¸ ReutilizaÃ§Ã£o

Se um componente:

* faz UMA coisa bem definida
* nÃ£o depende de contexto estranho

ğŸ‘‰ dÃ¡ pra reaproveitar em outro projeto tranquilamente.

---

### ğŸ§® M x N (essa parte Ã© genial)

* Componente A faz **M coisas**
* Componente B faz **N coisas**

Se forem ortogonais:
ğŸ‘‰ juntos fazem **M Ã— N possibilidades**

Se nÃ£o forem:
ğŸ‘‰ tem sobreposiÃ§Ã£o, conflito, limitaÃ§Ã£o

ğŸ’¡ Ortogonalidade = multiplicador de poder

---

## 2ï¸âƒ£ Menor risco

### ğŸ”¥ Se algo quebrarâ€¦

* o estrago fica **local**
* nÃ£o se espalha pelo sistema

---

### ğŸ§ª Testes ficam mais fÃ¡ceis

Porque:

* componentes sÃ£o pequenos
* previsÃ­veis
* independentes

---

### ğŸ¢ Menos dependÃªncia de fornecedor

Se vocÃª isola:

* banco
* framework
* biblioteca externa

ğŸ‘‰ trocar depois dÃ³i menos

---

# ğŸ‘¥ Ortogonalidade em equipes

Essa parte Ã© Ã³tima para trabalho real.

## Equipes nÃ£o ortogonais

* todo mundo mexe em tudo
* ninguÃ©m sabe exatamente sua responsabilidade
* qualquer mudanÃ§a exige reuniÃ£o com geral ğŸ˜µ

---

## Equipes ortogonais

* responsabilidades claras
* pouca sobreposiÃ§Ã£o
* cada grupo cuida do seu pedaÃ§o

ğŸ‘‰ Mais eficiÃªncia
ğŸ‘‰ Menos conflito

---

### ğŸ§ª Teste rÃ¡pido

Pergunta simples:

> â€œQuantas pessoas precisam discutir essa mudanÃ§a?â€

* Muitas pessoas â†’ baixa ortogonalidade
* Poucas pessoas â†’ boa ortogonalidade

---

# ğŸ—ï¸ Projeto de software (camadas)

Aqui entra o que vocÃª **com certeza jÃ¡ viu**:

* Interface
* LÃ³gica de negÃ³cio
* Banco
* Sistema operacional

ğŸ‘‰ Cada camada conversa sÃ³ com a de baixo
ğŸ‘‰ Cada uma tem sua responsabilidade

---

## ğŸ§  Teste de ouro da ortogonalidade

Pergunta mÃ¡gica:

> â€œSe eu mudar isso aqui drasticamente, quantos mÃ³dulos quebram?â€

Resposta ideal:
ğŸ‘‰ **UM**

---

### Exemplos prÃ¡ticos

* Mover botÃ£o da tela â‰  mexer no banco
* Adicionar ajuda â‰  mexer no sistema de cobranÃ§a

Se isso acontece:
ğŸ‘‰ sistema nÃ£o Ã© ortogonal

---

# â˜ï¸ Cuidado com o mundo real

Exemplo do livro:

* usar **telefone como ID de cliente**

Problema:

* telefone muda
* cÃ³digo de Ã¡rea muda
* regra externa muda

ğŸ‘‰ Nunca confie no que vocÃª **nÃ£o controla**

---

# ğŸ§° Bibliotecas e frameworks

Pergunta-chave ao usar algo externo:

> â€œIsso estÃ¡ forÃ§ando meu cÃ³digo a saber coisas que ele nÃ£o deveria?â€

Se sim:
ğŸ‘‰ nÃ£o Ã© ortogonal
ğŸ‘‰ vocÃª estÃ¡ acoplando demais

---

## ğŸ§¾ PersistÃªncia transparente = boa

* salvar objeto sem saber *como*
* buscar objeto sem saber *onde*

Se vocÃª precisa mudar todo seu cÃ³digo:
ğŸ‘‰ nÃ£o Ã© ortogonal

---

# ğŸ§  EJB, Aspectos e Logs

Esses exemplos mostram a ideia final:

ğŸ‘‰ **tirar preocupaÃ§Ãµes transversais do cÃ³digo principal**

Exemplos:

* transaÃ§Ãµes
* logs
* seguranÃ§a

Tudo isso:

* nÃ£o deveria poluir sua lÃ³gica de negÃ³cio
* deve ser **configurÃ¡vel**
* opcional

---

## ğŸ¯ Ideia final da ortogonalidade

> â€œCada coisa no seu lugar.
> Cada mudanÃ§a com impacto mÃ­nimo.
> Cada componente independente.â€

---