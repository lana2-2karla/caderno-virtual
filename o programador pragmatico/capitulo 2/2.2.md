# ğŸ§© ORTOGONALIDADE (sem dor de cabeÃ§a)

## ğŸ“Œ â€œA ortogonalidade Ã© um conceito crÃ­ticoâ€¦â€

**TraduÃ§Ã£o humana:**
Ortogonalidade Ã© MUITO importante se vocÃª quer criar sistemas que:

* sejam fÃ¡ceis de **pensar**
* fÃ¡ceis de **construir**
* fÃ¡ceis de **testar**
* fÃ¡ceis de **mexer depois sem quebrar tudo**

ğŸ‘‰ Em outras palavras: sistemas que **nÃ£o dÃ£o medo de alterar**.

---

## ğŸ“Œ â€œMas raramente esse conceito Ã© ensinado diretamenteâ€¦â€

Aqui o autor estÃ¡ reclamando ğŸ˜…
Ele diz que:

* ninguÃ©m ensina â€œortogonalidadeâ€ de forma explÃ­cita
* ela aparece escondida em conceitos como:

  * modularizaÃ§Ã£o
  * camadas
  * boas prÃ¡ticas
  * separaÃ§Ã£o de responsabilidades

ğŸ‘‰ O erro Ã© nÃ£o dar nome ao conceito.
Quando vocÃª entende **o nome e a ideia**, vocÃª comeÃ§a a **usar de propÃ³sito**.

---

## ğŸ“Œ â€œQuando vocÃª aprender a aplicar o princÃ­pio da ortogonalidade diretamenteâ€¦â€

**Resumo:**
Quando vocÃª comeÃ§a a pensar conscientemente:

> â€œIsso aqui estÃ¡ independente do resto?â€

a qualidade do seu sistema **sobe instantaneamente** ğŸ“ˆ

Ã‰ tipo aprender a cozinhar sabendo *por que* cada ingrediente existe, e nÃ£o sÃ³ seguir receita.

---

# ğŸ“ O que Ã© ortogonalidade?

## ğŸ“Œ Origem na geometria

Duas linhas ortogonais formam um **Ã¢ngulo de 90Â°** (como X e Y no grÃ¡fico).

* Mexe no eixo X â¡ï¸ nada acontece no Y
* Mexe no eixo Y â¡ï¸ nada acontece no X

ğŸ‘‰ **IndependÃªncia total**

---

## ğŸ“Œ Em termos simples

> â€œMover uma coisa nÃ£o afeta a outraâ€

---

## ğŸ“Œ Em computaÃ§Ã£o

Aqui vem a definiÃ§Ã£o-chave:

> Duas coisas sÃ£o ortogonais quando **alteraÃ§Ãµes em uma nÃ£o afetam a outra**

### ğŸ§  Exemplo clÃ¡ssico:

* Interface do usuÃ¡rio (tela, botÃµes)
* Banco de dados

ğŸ‘‰ VocÃª deveria conseguir:

* trocar a tela sem mexer no banco
* trocar o banco sem mexer na tela

Se nÃ£o consegue, o sistema **nÃ£o Ã© ortogonal** ğŸ˜¬

---

# ğŸš Sistema NÃƒO ortogonal (o helicÃ³ptero do caos)

Essa histÃ³ria Ã© uma **metÃ¡fora gigante**.

### O que acontece?

VocÃª mexe **um controle**â€¦

* e afeta **todos os outros**
* aÃ­ tenta corrigirâ€¦
* e cria **mais problemas**
* vira um ciclo infinito de ajustes

ğŸ‘‰ Isso Ã© um sistema **nÃ£o ortogonal**

---

## ğŸ’» TraduÃ§Ã£o para software

Ã‰ aquele sistema onde:

* vocÃª muda um botÃ£o na tela
* quebra o backend
* corrige o backend
* quebra o relatÃ³rio
* corrige o relatÃ³rio
* quebra o login ğŸ˜­

VocÃª vira o piloto desesperado do helicÃ³ptero.

---

## ğŸ“Œ ConclusÃ£o do exemplo

> â€œOs controles do helicÃ³ptero sÃ£o decididamente nÃ£o ortogonais.â€

Ou seja:

* tudo depende de tudo
* nada Ã© previsÃ­vel
* controlar Ã© difÃ­cil
* errar Ã© fÃ¡cil

---

# âœ… Vantagens da ortogonalidade

## ğŸ“Œ â€œSistemas nÃ£o ortogonais sÃ£o mais difÃ­ceis de mudarâ€

Porque:

* nada Ã© isolado
* nÃ£o existe â€œconserto localâ€
* mexer em um ponto espalha problemas

---

## ğŸ’¡ DICA 13

### â€œElimine efeitos entre elementos nÃ£o relacionadosâ€

Essa frase vale ouro ğŸ’›

ğŸ‘‰ **Se duas coisas nÃ£o tÃªm relaÃ§Ã£o direta, elas NÃƒO deveriam se afetar.**

---

## ğŸ§± Componentes autossuficientes

O autor fala de componentes que:

* fazem **uma coisa bem definida**
* nÃ£o dependem do resto
* nÃ£o vazam comportamento

Isso se chama **coesÃ£o**.

### ğŸ³ Exemplo do dia a dia:

* Liquidificador â†’ sÃ³ bate
* Geladeira â†’ sÃ³ refrigera
* FogÃ£o â†’ sÃ³ esquenta

Imagine se:

* ligar o fogÃ£o desligasse a geladeira
* abrir a geladeira mudasse a potÃªncia do liquidificador

ğŸ‘ Caos total
ğŸ‘ EletrodomÃ©sticos sÃ£o ortogonais

---

# ğŸš€ Duas grandes vantagens

## 1ï¸âƒ£ Maior produtividade

### Por quÃª?

* MudanÃ§as sÃ£o **localizadas**
* Componentes pequenos sÃ£o:

  * mais fÃ¡ceis de criar
  * mais fÃ¡ceis de testar
  * mais fÃ¡ceis de entender

ğŸ‘‰ VocÃª cria, testa, confia e **segue a vida**.

---

### â™»ï¸ ReutilizaÃ§Ã£o

Se um componente:

* faz UMA coisa bem definida
* nÃ£o depende de contexto estranho

ğŸ‘‰ dÃ¡ pra reaproveitar em outro projeto tranquilamente.

---

### ğŸ§® M x N (essa parte Ã© genial)

* Componente A faz **M coisas**
* Componente B faz **N coisas**

Se forem ortogonais:
ğŸ‘‰ juntos fazem **M Ã— N possibilidades**

Se nÃ£o forem:
ğŸ‘‰ tem sobreposiÃ§Ã£o, conflito, limitaÃ§Ã£o

ğŸ’¡ Ortogonalidade = multiplicador de poder

---

## 2ï¸âƒ£ Menor risco

### ğŸ”¥ Se algo quebrarâ€¦

* o estrago fica **local**
* nÃ£o se espalha pelo sistema

---

### ğŸ§ª Testes ficam mais fÃ¡ceis

Porque:

* componentes sÃ£o pequenos
* previsÃ­veis
* independentes

---

### ğŸ¢ Menos dependÃªncia de fornecedor

Se vocÃª isola:

* banco
* framework
* biblioteca externa

ğŸ‘‰ trocar depois dÃ³i menos

---

# ğŸ‘¥ Ortogonalidade em equipes

Essa parte Ã© Ã³tima para trabalho real.

## Equipes nÃ£o ortogonais

* todo mundo mexe em tudo
* ninguÃ©m sabe exatamente sua responsabilidade
* qualquer mudanÃ§a exige reuniÃ£o com geral ğŸ˜µ

---

## Equipes ortogonais

* responsabilidades claras
* pouca sobreposiÃ§Ã£o
* cada grupo cuida do seu pedaÃ§o

ğŸ‘‰ Mais eficiÃªncia
ğŸ‘‰ Menos conflito

---

### ğŸ§ª Teste rÃ¡pido

Pergunta simples:

> â€œQuantas pessoas precisam discutir essa mudanÃ§a?â€

* Muitas pessoas â†’ baixa ortogonalidade
* Poucas pessoas â†’ boa ortogonalidade

---

# ğŸ—ï¸ Projeto de software (camadas)

Aqui entra o que vocÃª **com certeza jÃ¡ viu**:

* Interface
* LÃ³gica de negÃ³cio
* Banco
* Sistema operacional

ğŸ‘‰ Cada camada conversa sÃ³ com a de baixo
ğŸ‘‰ Cada uma tem sua responsabilidade

---

## ğŸ§  Teste de ouro da ortogonalidade

Pergunta mÃ¡gica:

> â€œSe eu mudar isso aqui drasticamente, quantos mÃ³dulos quebram?â€

Resposta ideal:
ğŸ‘‰ **UM**

---

### Exemplos prÃ¡ticos

* Mover botÃ£o da tela â‰  mexer no banco
* Adicionar ajuda â‰  mexer no sistema de cobranÃ§a

Se isso acontece:
ğŸ‘‰ sistema nÃ£o Ã© ortogonal

---

# â˜ï¸ Cuidado com o mundo real

Exemplo do livro:

* usar **telefone como ID de cliente**

Problema:

* telefone muda
* cÃ³digo de Ã¡rea muda
* regra externa muda

ğŸ‘‰ Nunca confie no que vocÃª **nÃ£o controla**

---

# ğŸ§° Bibliotecas e frameworks

Pergunta-chave ao usar algo externo:

> â€œIsso estÃ¡ forÃ§ando meu cÃ³digo a saber coisas que ele nÃ£o deveria?â€

Se sim:
ğŸ‘‰ nÃ£o Ã© ortogonal
ğŸ‘‰ vocÃª estÃ¡ acoplando demais

---

## ğŸ§¾ PersistÃªncia transparente = boa

* salvar objeto sem saber *como*
* buscar objeto sem saber *onde*

Se vocÃª precisa mudar todo seu cÃ³digo:
ğŸ‘‰ nÃ£o Ã© ortogonal

---

# ğŸ§  EJB, Aspectos e Logs

Esses exemplos mostram a ideia final:

ğŸ‘‰ **tirar preocupaÃ§Ãµes transversais do cÃ³digo principal**

Exemplos:

* transaÃ§Ãµes
* logs
* seguranÃ§a

Tudo isso:

* nÃ£o deveria poluir sua lÃ³gica de negÃ³cio
* deve ser **configurÃ¡vel**
* opcional

---

## ğŸ¯ Ideia final da ortogonalidade

> â€œCada coisa no seu lugar.
> Cada mudanÃ§a com impacto mÃ­nimo.
> Cada componente independente.â€

---

Maravilha ğŸ˜„
Vamos continuar **no mesmo estilo: linha a linha, leve, divertida, com exemplos da vida real** â€” agora focando em **codificaÃ§Ã£o, testes, documentaÃ§Ã£o e vida real**.

Pega um cafÃ© â˜•, porque agora isso aqui vai **clicar** na sua cabeÃ§a.

---

# ğŸ’» CODIFICANDO (onde tudo pode dar ruim ğŸ˜…)

## ğŸ“Œ â€œSempre que criar um cÃ³digo, vocÃª estarÃ¡ correndo o risco de reduzir a ortogonalidadeâ€¦â€

**TraduÃ§Ã£o sincera:**
Toda vez que vocÃª escreve cÃ³digo, existe o risco de:

* criar dependÃªncias desnecessÃ¡rias
* misturar responsabilidades
* colar coisas que deveriam ser separadas

ğŸ‘‰ Ortogonalidade **nÃ£o Ã© automÃ¡tica**.
Ela exige vigilÃ¢ncia constante ğŸ‘€

---

## ğŸ“Œ â€œA menos que monitore constantementeâ€¦ pode duplicar funcionalidadesâ€

Isso acontece quando:

* vocÃª nÃ£o olha o sistema como um todo
* resolve um problema local sem perceber que ele jÃ¡ foi resolvido em outro lugar

### ğŸ  Exemplo do dia a dia:

Imagine uma casa onde:

* a sala tem um interruptor para apagar a luz
* o quarto tambÃ©m controla a luz da sala
* a cozinha tambÃ©m ğŸ˜µ

Resultado:
ninguÃ©m sabe **onde mexer**, e qualquer mudanÃ§a dÃ¡ confusÃ£o.

---

## ğŸ§  TÃ©cnicas para manter a ortogonalidade

Agora o livro entra no **â€œcomo fazerâ€**.

---

## ğŸ”Œ 1ï¸âƒ£ Mantenha seu cÃ³digo desvinculado

### ğŸ“Œ â€œEscreva cÃ³digos cautelososâ€¦â€

CÃ³digo cauteloso Ã© cÃ³digo que:

* nÃ£o revela detalhes internos
* nÃ£o depende de *como* o outro mÃ³dulo funciona por dentro

ğŸ‘‰ Ele sÃ³ conhece a **interface**, nÃ£o a implementaÃ§Ã£o.

---

### ğŸ“¦ Exemplo simples

VocÃª pede comida pelo app:

* vocÃª nÃ£o sabe se o restaurante usa fogÃ£o a gÃ¡s ou elÃ©trico
* vocÃª sÃ³ sabe que **vai chegar comida**

Isso Ã© **desvinculaÃ§Ã£o**.

---

## ğŸ“Œ â€œUse a Lei de DemÃ©terâ€

A Lei de DemÃ©ter, em linguagem humana:

> â€œFale apenas com seus amigos diretos, nÃ£o com estranhos.â€

### âŒ Ruim:

```ts
pedido.cliente.endereco.rua
```

### âœ… Melhor:

```ts
pedido.getEnderecoEntrega()
```

ğŸ‘‰ Se o endereÃ§o mudar internamente:

* sÃ³ o objeto sabe
* o resto do cÃ³digo nÃ£o quebra

---

## ğŸ“Œ â€œSe tiver de alterar o estado de um objeto, deixe que o objeto faÃ§a issoâ€

### ğŸ• Exemplo real:

VocÃª **nÃ£o entra na cozinha** de um restaurante pra virar a pizza.

VocÃª diz:

> â€œQuero uma pizza meia calabresaâ€

O restaurante se vira.

ğŸ‘‰ Objeto bem feito **cuida do prÃ³prio estado**.

---

## ğŸŒ 2ï¸âƒ£ Evite dados globais

### ğŸ“Œ â€œSempre que seu cÃ³digo referenciar dados globaisâ€¦â€

Dados globais sÃ£o tipo:

* todo mundo vÃª
* todo mundo mexe
* ninguÃ©m sabe quem alterou

ğŸ‘‰ Eles colam mÃ³dulos que nÃ£o deveriam se conhecer.

---

### ğŸ¢ Exemplo da vida real

Imagine um **quadro branco no escritÃ³rio** onde qualquer pessoa pode:

* apagar
* escrever
* alterar dados crÃ­ticos

Resultado:

* confusÃ£o
* bugs invisÃ­veis
* brigas ğŸ˜…

---

## ğŸ“Œ â€œMesmo dados globais sÃ³ para leitura podem dar problemaâ€

Hoje vocÃª:

* lÃª um valor global

AmanhÃ£:

* precisa rodar mÃºltiplas instÃ¢ncias
* ou vÃ¡rios usuÃ¡rios

ğŸ‘‰ O que era â€œsÃ³ leituraâ€ vira problema estrutural.

---

## ğŸ“Œ â€œPasse o contexto explicitamenteâ€

Muito importante isso aqui ğŸ‘‡

Ao invÃ©s de:

* pegar coisas escondidas

VocÃª:

* **passa tudo que o mÃ³dulo precisa**

### ğŸ’ Exemplo:

NÃ£o presuma que alguÃ©m sabe para onde ir.
DÃª:

* endereÃ§o
* horÃ¡rio
* instruÃ§Ãµes

---

### ğŸ’¡ Em OO

* contexto vai no **construtor**

### ğŸ’¡ Em outros cÃ³digos

* passa uma estrutura de contexto

---

## âš ï¸ Singleton â‰  soluÃ§Ã£o mÃ¡gica

### ğŸ“Œ â€œMuitas pessoas usam singleton como variÃ¡vel globalâ€

Singleton:

* garante uma Ãºnica instÃ¢ncia
* **nÃ£o garante boa arquitetura**

ğŸ‘‰ Se todo mundo acessa:

* virou global disfarÃ§ado ğŸ¥¸

---

### ğŸ§  Regra prÃ¡tica

Se vocÃª pensa:

> â€œVou usar singleton porque Ã© mais fÃ¡cilâ€¦â€

ğŸš¨ alerta de acoplamento

---

## ğŸ” 3ï¸âƒ£ Evite funÃ§Ãµes semelhantes

### ğŸ“Œ â€œFunÃ§Ãµes de aparÃªncia semelhanteâ€¦â€

Isso Ã© aquele cÃ³digo tipo:

```ts
calculaPrecoA()
calculaPrecoB()
calculaPrecoC()
```

Todas:

* comeÃ§am igual
* terminam igual
* sÃ³ mudam no meio

ğŸ‘‰ Isso Ã© **cheiro de cÃ³digo duplicado**.

---

### ğŸ­ Exemplo real

TrÃªs funcionÃ¡rios:

* fazem o mesmo processo
* sÃ³ mudam uma etapa

ğŸ‘‰ Melhor:

* um processo Ãºnico
* com estratÃ©gia diferente

---

### ğŸ¯ Strategy Pattern

VocÃª separa:

* o que muda
* do que Ã© fixo

Resultado:

* menos duplicaÃ§Ã£o
* mais ortogonalidade

---

## ğŸ”§ RefatoraÃ§Ã£o

### ğŸ“Œ â€œSeja constantemente crÃ­tico com seu cÃ³digoâ€

CÃ³digo nÃ£o Ã© sagrado.
CÃ³digo:

* envelhece
* acumula gambiarra
* perde clareza

ğŸ‘‰ Refatorar Ã©:

* organizar
* limpar
* separar responsabilidades

Sem mudar comportamento.

---

# ğŸ§ª TESTANDO (onde a ortogonalidade brilha)

## ğŸ“Œ â€œSistema ortogonal Ã© mais fÃ¡cil de testarâ€

Por quÃª?

* menos dependÃªncias
* menos contexto
* menos setup

---

## ğŸ§© Teste de unidade

VocÃª testa:

* um mÃ³dulo
* isolado
* sem levantar o sistema inteiro

ğŸ‘‰ Isso sÃ³ Ã© possÃ­vel se o sistema for ortogonal.

---

### ğŸš¨ Alerta importante

Se para testar um mÃ³dulo vocÃª precisa:

* banco
* fila
* API
* servidor

ğŸ‘‰ esse mÃ³dulo **nÃ£o Ã© independente o suficiente**.

---

## ğŸ” Testar Ã© medir ortogonalidade

Pergunta-chave:

> â€œO que eu preciso para rodar esse teste?â€

Se a resposta for:

* â€œquase tudoâ€ ğŸ˜¬
  problema estrutural detectado.

---

## ğŸ Corrigir bugs = auditoria de arquitetura

Quando um bug aparece, observe:

* Corrigi **um arquivo** ou **dez**?
* Apareceram bugs novos depois?

ğŸ‘‰ Bugs em cascata = baixa ortogonalidade

---

## ğŸ“Š Controle de versÃ£o ajuda

Marcar commits de correÃ§Ã£o permite:

* ver padrÃµes
* identificar mÃ³dulos problemÃ¡ticos
* decidir onde refatorar

---

# ğŸ“š DOCUMENTAÃ‡ÃƒO TAMBÃ‰M TEM ORTOGONALIDADE

Isso Ã© muito elegante ğŸ‘Œ

## ğŸ“Œ ConteÃºdo â‰  apresentaÃ§Ã£o

VocÃª deveria conseguir:

* mudar fonte
* layout
* cores
* formato

ğŸ‘‰ sem mexer no conteÃºdo.

---

### ğŸ“ Exemplo real

Um texto em Markdown:

* pode virar PDF
* site
* Word

Sem mudar o texto.

ğŸ‘‰ Isso Ã© documentaÃ§Ã£o ortogonal.

---

# ğŸŒ± VIVENDO COM A ORTOGONALIDADE

Aqui o autor fecha com chave de ouro ğŸ”‘

## ğŸ“Œ Ortogonalidade + NSR (NÃ£o Se Repita)

* NSR â†’ elimina duplicaÃ§Ã£o
* Ortogonalidade â†’ elimina dependÃªncia

ğŸ‘‰ Juntos:

* sistemas flexÃ­veis
* fÃ¡ceis de entender
* fÃ¡ceis de mudar

---

## ğŸš O helicÃ³ptero de novo

Se vocÃª entra num projeto onde:

* toda mudanÃ§a quebra 4 coisas
* ninguÃ©m sabe onde mexer
* todo mundo tem medo

ğŸ‘‰ nÃ£o Ã© azar
ğŸ‘‰ Ã© falta de ortogonalidade

ğŸ’¡ **Hora de refatorar.**

---

## ğŸŸ Ãšltima liÃ§Ã£o

> â€œE, se vocÃª for um piloto de helicÃ³ptero, nÃ£o coma o peixe.â€

TraduÃ§Ã£o final:

* arquitetura importa
* independÃªncia salva vidas (e projetos)
* e mÃ¡s decisÃµes voltam pra te assombrar ğŸ˜‚