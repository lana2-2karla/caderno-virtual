## ğŸŒ± Uma Abordagem PragmÃ¡tica

### ğŸ“Œ â€œHÃ¡ certas dicas e truques que se aplicam a todos os nÃ­veis de desenvolvimento de software...â€

Aqui o autor jÃ¡ comeÃ§a dando um *spoiler importante*:
existem **princÃ­pios que funcionam para todo mundo**, nÃ£o importa se vocÃª Ã©:

* dev jÃºnior,
* pleno,
* sÃªnior,
* tech lead,
* ou alguÃ©m que acabou de descobrir o que Ã© um `git rebase`.

Essas ideias sÃ£o quase como **leis da gravidade do desenvolvimento**.
VocÃª pode atÃ© ignorarâ€¦ mas uma hora elas te puxam pra baixo ğŸ˜….

ğŸ“ **Exemplo do dia a dia**
Todo dev, cedo ou tarde, aprende coisas como:

* cÃ³digo duplicado dÃ¡ problema,
* mudar requisito Ã© normal,
* manutenÃ§Ã£o dÃ¡ mais trabalho que feature nova,
* â€œsÃ³ um ifzinhoâ€ vira um monstro depois.

Essas coisas nÃ£o estÃ£o presas a uma linguagem ou framework â€” sÃ£o universais.

---

### ğŸ“Œ â€œNo entanto, raramente essas abordagens sÃ£o documentadas como deveriam...â€

Aqui o autor critica um problema clÃ¡ssico:
essas boas prÃ¡ticas **existem**, mas quase nunca estÃ£o bem explicadas.

Normalmente elas aparecem como:

* frases soltas em review de PR

  > â€œacho melhor nÃ£o duplicar issoâ€
* comentÃ¡rios perdidos no Jira

  > â€œisso aqui pode virar problema depoisâ€
* ou conselhos misteriosos de um dev mais experiente

  > â€œconfia em mimâ€¦ nÃ£o faz assimâ€

Ou seja: o conhecimento existe, mas fica espalhado e mal registrado.

ğŸ“ **Exemplo real**
VocÃª aprende uma boa prÃ¡tica:

* nÃ£o por um livro,
* mas porque **alguÃ©m reclamou no seu PR**.

---

### ğŸ“Œ â€œNeste capÃ­tulo, reuniremos essas ideias e processos...â€

Aqui o autor diz:

> â€œrelaxa, eu vou organizar essa bagunÃ§aâ€.

O objetivo do capÃ­tulo Ã© **juntar essas ideias soltas**, dar nome a elas e mostrar como usar no dia a dia.

Ã‰ tipo quando alguÃ©m pega vÃ¡rias dicas jogadas no Slack e transforma num **guia decente**.

---

## ğŸ”— Os Males da DuplicaÃ§Ã£o & Ortogonalidade

### ğŸ“Œ â€œAs primeiras duas seÃ§Ãµes... estÃ£o intimamente relacionadas...â€

Aqui ele apresenta dois conceitos que andam juntos:

1. **Os Males da DuplicaÃ§Ã£o**

   * NÃ£o repetir a mesma informaÃ§Ã£o em vÃ¡rios lugares.

2. **Ortogonalidade**

   * NÃ£o espalhar partes de uma mesma informaÃ§Ã£o por vÃ¡rios componentes.

ğŸ“ **Analogia simples**

* DuplicaÃ§Ã£o: copiar e colar o mesmo cÃ³digo em trÃªs arquivos.
* Falta de ortogonalidade: uma regra de negÃ³cio comeÃ§a no backend, continua no frontend e termina num cron job ğŸ˜µâ€ğŸ’«.

---

### ğŸ“Œ â€œA primeira o advertirÃ¡ a nÃ£o duplicar informaÃ§Ãµes...â€

Essa parte foca no clÃ¡ssico:

> **copiar e colar = dÃ­vida tÃ©cnica futura**

Sempre que vocÃª duplica informaÃ§Ã£o:

* vocÃª cria **dois pontos de manutenÃ§Ã£o**,
* aumenta a chance de inconsistÃªncia,
* e garante sofrimento no futuro.

---

### ğŸ“Œ â€œÃ€ medida que a velocidade da mudanÃ§a aumenta... Reversibilidade...â€

Aqui o autor muda o foco para um problema moderno (e muito atual):

ğŸ‘‰ **Tudo muda o tempo todo**

* tecnologia,
* regras de negÃ³cio,
* frameworks,
* banco de dados,
* infraestrutura.

A seÃ§Ã£o de **Reversibilidade** vai ensinar como **nÃ£o se casar com decisÃµes tÃ©cnicas**.

ğŸ“ **Exemplo prÃ¡tico**

* Hoje vocÃª usa Mongo.
* AmanhÃ£ precisa ir pra PostgreSQL.
* Se seu cÃ³digo estiver todo acoplado ao Mongo, vocÃª chora.
* Se estiver desacoplado, vocÃª sofreâ€¦ mas sobrevive.

---

## ğŸš€ ProjÃ©teis Luminosos (Tracer Bullets)

### ğŸ“Œ â€œAs duas seÃ§Ãµes seguintes tambÃ©m estÃ£o relacionadas...â€

Aqui entra um conceito bem legal:

ğŸ‘‰ desenvolver **um caminho funcional de ponta a ponta**, mesmo que simples.

NÃ£o Ã© o sistema completo.
Ã‰ algo que:

* funciona,
* passa por todas as camadas,
* e gera feedback rÃ¡pido.

ğŸ“ **Exemplo**

* Uma API simples que salva algo no banco,
* um endpoint bÃ¡sico,
* sem validaÃ§Ãµes perfeitas,
* sem performance ideal,
* mas funcionando.

Isso ajuda a:

* validar arquitetura,
* entender requisitos,
* ajustar expectativas cedo.

âš ï¸ Mas o autor jÃ¡ avisa:
isso **nÃ£o funciona sempre**.

---

### ğŸ“Œ â€œProtÃ³tipos e notas post-it...â€

Quando o â€œprojÃ©til luminosoâ€ nÃ£o faz sentido, entram os **protÃ³tipos**.

ProtÃ³tipo serve para:

* testar ideias,
* validar conceitos,
* errar rÃ¡pido,
* jogar fora sem culpa.

ğŸ“ **Exemplo**

* um mock de interface,
* um script rÃ¡pido,
* uma POC jogada no GitHub,
* um desenho no Miro.

O importante: **nÃ£o confundir protÃ³tipo com produto final**.

---

## ğŸ§  Linguagens de DomÃ­nio

### ğŸ“Œ â€œConforme a ciÃªncia da computaÃ§Ã£o evolui...â€

Aqui o autor fala sobre linguagens de mais alto nÃ­vel.

O sonho seria escrever:

```txt
execute
```

e o computador fazer tudo sozinho ğŸ˜„
Mas enquanto isso nÃ£o existeâ€¦

ğŸ‘‰ a ideia Ã© criar **mini linguagens** ou abstraÃ§Ãµes prÃ³ximas do problema.

ğŸ“ **Exemplo**

* DSLs,
* configs bem pensadas,
* funÃ§Ãµes que falam a linguagem do negÃ³cio,
* cÃ³digo que parece uma regra, nÃ£o um algoritmo.

Isso torna o cÃ³digo:

* mais legÃ­vel,
* mais expressivo,
* mais fÃ¡cil de mudar.

---

## â±ï¸ Estimativas

### ğŸ“Œ â€œPara concluir, todos trabalhamos em um mundo de tempo e recursos limitados...â€

Aqui vem a realidade nua e crua:

* prazo curto,
* time pequeno,
* orÃ§amento limitado,
* chefe cobrando.

Saber **estimar tarefas** nÃ£o Ã© sÃ³ habilidade tÃ©cnica:

* Ã© sobrevivÃªncia profissional.

ğŸ“ **Exemplo**
Quem estima mal:

* promete demais,
* entrega atrasado,
* perde confianÃ§a.

Quem estima melhor:

* negocia escopo,
* ajusta expectativas,
* sofre menos.

---

## ğŸ¯ ConclusÃ£o do CapÃ­tulo

### ğŸ“Œ â€œMantendo esses princÃ­pios bÃ¡sicos em mente...â€

O autor fecha dizendo:

* esses princÃ­pios nÃ£o sÃ£o mÃ¡gicos,
* mas **melhoram tudo**:

  * qualidade,
  * velocidade,
  * consistÃªncia.

E simâ€¦
Pode atÃ© parecer fÃ¡cil no papel.
DifÃ­cil Ã© aplicar **todo dia**, sob pressÃ£o ğŸ˜….

---

# âš ï¸ CapÃ­tulo 7 â€” Os Males da DuplicaÃ§Ã£o

## ğŸ–– IntroduÃ§Ã£o com Star Trek

### ğŸ“Œ â€œFornecer ao computador dois blocos de informaÃ§Ãµes contraditÃ³rios...â€

Aqui o autor comeÃ§a com uma metÃ¡fora genial:

ğŸ‘‰ Em Star Trek, o CapitÃ£o Kirk derrotava IAs dando **ordens contraditÃ³rias**.

No software, fazemos isso o tempo todo sem perceber:

* regra em um lugar,
* regra diferente em outro.

Resultado?
ğŸ’¥ sistema quebra.

---

## ğŸ“š O papel do programador

### ğŸ“Œ â€œComo programadores, coletamos, organizamos...â€

Nosso trabalho gira em torno de **informaÃ§Ã£o**:

* requisitos,
* regras,
* validaÃ§Ãµes,
* dados.

Essas informaÃ§Ãµes aparecem:

* na documentaÃ§Ã£o,
* no cÃ³digo,
* nos testes.

---

## ğŸ”„ O problema: tudo muda

### ğŸ“Œ â€œInfelizmente, as informaÃ§Ãµes nÃ£o sÃ£o estÃ¡veis...â€

Nada fica parado:

* cliente muda ideia,
* lei muda,
* algoritmo nÃ£o funciona,
* requisito evolui.

Por isso:
ğŸ‘‰ **manutenÃ§Ã£o nÃ£o Ã© exceÃ§Ã£o, Ã© regra**.

---

## ğŸ”§ ManutenÃ§Ã£o nÃ£o comeÃ§a no deploy

### ğŸ“Œ â€œA maioria das pessoas considera que a manutenÃ§Ã£o comeÃ§a quando...â€

Aqui o autor quebra um mito importante:

ğŸš« ManutenÃ§Ã£o **nÃ£o comeÃ§a depois do lanÃ§amento**
âœ… ManutenÃ§Ã£o comeÃ§a **no primeiro dia de desenvolvimento**

Toda vez que vocÃª:

* ajusta entendimento,
* muda uma funÃ§Ã£o,
* refatora algo,

ğŸ‘‰ vocÃª estÃ¡ fazendo manutenÃ§Ã£o.

---

## ğŸ’£ Onde a duplicaÃ§Ã£o vira um pesadelo

### ğŸ“Œ â€œQuando trabalhamos em manutenÃ§Ã£o...â€

Manter software significa:

* achar onde a informaÃ§Ã£o estÃ¡,
* alterar todas as representaÃ§Ãµes dela.

Se ela estiver duplicada:
ğŸ˜± vocÃª vai esquecer algum lugar.

---

## ğŸ§  PrincÃ­pio NSR â€” NÃ£o Se Repita

### ğŸ“Œ DefiniÃ§Ã£o

> **Cada bloco de informaÃ§Ã£o deve ter uma representaÃ§Ã£o oficial, exclusiva e sem ambiguidades dentro de um sistema.**

Ou seja:

* uma fonte da verdade,
* um lugar certo,
* zero cÃ³pias espalhadas.

---

### ğŸ“Œ Por que isso Ã© tÃ£o importante?

Se vocÃª duplica:

* nÃ£o Ã© *se* vai dar problema,
* Ã© *quando*.

---

## ğŸ” Tipos de duplicaÃ§Ã£o

### 1ï¸âƒ£ DuplicaÃ§Ã£o imposta

O sistema, linguagem ou ambiente forÃ§a.

### 2ï¸âƒ£ DuplicaÃ§Ã£o inadvertida

VocÃª nem percebe que duplicou.

### 3ï¸âƒ£ DuplicaÃ§Ã£o impaciente

â€œDepois eu arrumoâ€ (spoiler: nunca arruma).

### 4ï¸âƒ£ DuplicaÃ§Ã£o entre desenvolvedores

Cada pessoa faz do seu jeito.

---

## ğŸ§© DuplicaÃ§Ã£o imposta (detalhada)

### ğŸ“Œ VÃ¡rias representaÃ§Ãµes da informaÃ§Ã£o

Exemplos comuns:

* frontend e backend,
* classe e tabela de banco,
* cÃ³digo e exemplo em documentaÃ§Ã£o.

ğŸ’¡ SoluÃ§Ã£o:

* geradores de cÃ³digo,
* metadados,
* automaÃ§Ã£o.

O segredo:
ğŸ‘‰ o processo precisa ser **automÃ¡tico e contÃ­nuo**.

---

### ğŸ“Œ DocumentaÃ§Ã£o no cÃ³digo

CÃ³digo bom:

* se explica sozinho.

ComentÃ¡rios devem explicar:

* **por quÃª**,
* nÃ£o **o quÃª**.

ComentÃ¡rio duplicando cÃ³digo:

* fica desatualizado,
* engana quem lÃª,
* Ã© pior que nenhum comentÃ¡rio.

---

### ğŸ“Œ DocumentaÃ§Ã£o e cÃ³digo

Quando doc e cÃ³digo dizem a mesma coisa:

* alguÃ©m vai esquecer de atualizar um deles.

ğŸ’¡ SoluÃ§Ã£o real usada:

* gerar testes a partir da documentaÃ§Ã£o.

Assim:

* mudou a doc â†’ testes mudam,
* inconsistÃªncia vira impossÃ­vel.

---

### ğŸ“Œ Problemas de linguagem

Algumas linguagens **forÃ§am duplicaÃ§Ã£o**:

* headers,
* interfaces,
* IDLs.

Aqui nÃ£o tem milagre.
A boa notÃ­cia:

* erro aparece rÃ¡pido (compilaÃ§Ã£o).

---

### ğŸ“Œ ComentÃ¡rios em headers e implementaÃ§Ã£o

Regra simples:

* header: o que o usuÃ¡rio precisa saber
* implementaÃ§Ã£o: como funciona por dentro

Duplicar comentÃ¡rio = trabalho dobrado.