## ğŸŒ± Uma Abordagem PragmÃ¡tica

### ğŸ“Œ â€œHÃ¡ certas dicas e truques que se aplicam a todos os nÃ­veis de desenvolvimento de software...â€

Aqui o autor jÃ¡ comeÃ§a dando um *spoiler importante*:
existem **princÃ­pios que funcionam para todo mundo**, nÃ£o importa se vocÃª Ã©:

* dev jÃºnior,
* pleno,
* sÃªnior,
* tech lead,
* ou alguÃ©m que acabou de descobrir o que Ã© um `git rebase`.

Essas ideias sÃ£o quase como **leis da gravidade do desenvolvimento**.
VocÃª pode atÃ© ignorarâ€¦ mas uma hora elas te puxam pra baixo ğŸ˜….

ğŸ“ **Exemplo do dia a dia**
Todo dev, cedo ou tarde, aprende coisas como:

* cÃ³digo duplicado dÃ¡ problema,
* mudar requisito Ã© normal,
* manutenÃ§Ã£o dÃ¡ mais trabalho que feature nova,
* â€œsÃ³ um ifzinhoâ€ vira um monstro depois.

Essas coisas nÃ£o estÃ£o presas a uma linguagem ou framework â€” sÃ£o universais.

---

### ğŸ“Œ â€œNo entanto, raramente essas abordagens sÃ£o documentadas como deveriam...â€

Aqui o autor critica um problema clÃ¡ssico:
essas boas prÃ¡ticas **existem**, mas quase nunca estÃ£o bem explicadas.

Normalmente elas aparecem como:

* frases soltas em review de PR

  > â€œacho melhor nÃ£o duplicar issoâ€
* comentÃ¡rios perdidos no Jira

  > â€œisso aqui pode virar problema depoisâ€
* ou conselhos misteriosos de um dev mais experiente

  > â€œconfia em mimâ€¦ nÃ£o faz assimâ€

Ou seja: o conhecimento existe, mas fica espalhado e mal registrado.

ğŸ“ **Exemplo real**
VocÃª aprende uma boa prÃ¡tica:

* nÃ£o por um livro,
* mas porque **alguÃ©m reclamou no seu PR**.

---

### ğŸ“Œ â€œNeste capÃ­tulo, reuniremos essas ideias e processos...â€

Aqui o autor diz:

> â€œrelaxa, eu vou organizar essa bagunÃ§aâ€.

O objetivo do capÃ­tulo Ã© **juntar essas ideias soltas**, dar nome a elas e mostrar como usar no dia a dia.

Ã‰ tipo quando alguÃ©m pega vÃ¡rias dicas jogadas no Slack e transforma num **guia decente**.

---

## ğŸ”— Os Males da DuplicaÃ§Ã£o & Ortogonalidade

### ğŸ“Œ â€œAs primeiras duas seÃ§Ãµes... estÃ£o intimamente relacionadas...â€

Aqui ele apresenta dois conceitos que andam juntos:

1. **Os Males da DuplicaÃ§Ã£o**

   * NÃ£o repetir a mesma informaÃ§Ã£o em vÃ¡rios lugares.

2. **Ortogonalidade**

   * NÃ£o espalhar partes de uma mesma informaÃ§Ã£o por vÃ¡rios componentes.

ğŸ“ **Analogia simples**

* DuplicaÃ§Ã£o: copiar e colar o mesmo cÃ³digo em trÃªs arquivos.
* Falta de ortogonalidade: uma regra de negÃ³cio comeÃ§a no backend, continua no frontend e termina num cron job ğŸ˜µâ€ğŸ’«.

---

### ğŸ“Œ â€œA primeira o advertirÃ¡ a nÃ£o duplicar informaÃ§Ãµes...â€

Essa parte foca no clÃ¡ssico:

> **copiar e colar = dÃ­vida tÃ©cnica futura**

Sempre que vocÃª duplica informaÃ§Ã£o:

* vocÃª cria **dois pontos de manutenÃ§Ã£o**,
* aumenta a chance de inconsistÃªncia,
* e garante sofrimento no futuro.

---

### ğŸ“Œ â€œÃ€ medida que a velocidade da mudanÃ§a aumenta... Reversibilidade...â€

Aqui o autor muda o foco para um problema moderno (e muito atual):

ğŸ‘‰ **Tudo muda o tempo todo**

* tecnologia,
* regras de negÃ³cio,
* frameworks,
* banco de dados,
* infraestrutura.

A seÃ§Ã£o de **Reversibilidade** vai ensinar como **nÃ£o se casar com decisÃµes tÃ©cnicas**.

ğŸ“ **Exemplo prÃ¡tico**

* Hoje vocÃª usa Mongo.
* AmanhÃ£ precisa ir pra PostgreSQL.
* Se seu cÃ³digo estiver todo acoplado ao Mongo, vocÃª chora.
* Se estiver desacoplado, vocÃª sofreâ€¦ mas sobrevive.

---

## ğŸš€ ProjÃ©teis Luminosos (Tracer Bullets)

### ğŸ“Œ â€œAs duas seÃ§Ãµes seguintes tambÃ©m estÃ£o relacionadas...â€

Aqui entra um conceito bem legal:

ğŸ‘‰ desenvolver **um caminho funcional de ponta a ponta**, mesmo que simples.

NÃ£o Ã© o sistema completo.
Ã‰ algo que:

* funciona,
* passa por todas as camadas,
* e gera feedback rÃ¡pido.

ğŸ“ **Exemplo**

* Uma API simples que salva algo no banco,
* um endpoint bÃ¡sico,
* sem validaÃ§Ãµes perfeitas,
* sem performance ideal,
* mas funcionando.

Isso ajuda a:

* validar arquitetura,
* entender requisitos,
* ajustar expectativas cedo.

âš ï¸ Mas o autor jÃ¡ avisa:
isso **nÃ£o funciona sempre**.

---

### ğŸ“Œ â€œProtÃ³tipos e notas post-it...â€

Quando o â€œprojÃ©til luminosoâ€ nÃ£o faz sentido, entram os **protÃ³tipos**.

ProtÃ³tipo serve para:

* testar ideias,
* validar conceitos,
* errar rÃ¡pido,
* jogar fora sem culpa.

ğŸ“ **Exemplo**

* um mock de interface,
* um script rÃ¡pido,
* uma POC jogada no GitHub,
* um desenho no Miro.

O importante: **nÃ£o confundir protÃ³tipo com produto final**.

---

## ğŸ§  Linguagens de DomÃ­nio

### ğŸ“Œ â€œConforme a ciÃªncia da computaÃ§Ã£o evolui...â€

Aqui o autor fala sobre linguagens de mais alto nÃ­vel.

O sonho seria escrever:

```txt
execute
```

e o computador fazer tudo sozinho ğŸ˜„
Mas enquanto isso nÃ£o existeâ€¦

ğŸ‘‰ a ideia Ã© criar **mini linguagens** ou abstraÃ§Ãµes prÃ³ximas do problema.

ğŸ“ **Exemplo**

* DSLs,
* configs bem pensadas,
* funÃ§Ãµes que falam a linguagem do negÃ³cio,
* cÃ³digo que parece uma regra, nÃ£o um algoritmo.

Isso torna o cÃ³digo:

* mais legÃ­vel,
* mais expressivo,
* mais fÃ¡cil de mudar.

---

## â±ï¸ Estimativas

### ğŸ“Œ â€œPara concluir, todos trabalhamos em um mundo de tempo e recursos limitados...â€

Aqui vem a realidade nua e crua:

* prazo curto,
* time pequeno,
* orÃ§amento limitado,
* chefe cobrando.

Saber **estimar tarefas** nÃ£o Ã© sÃ³ habilidade tÃ©cnica:

* Ã© sobrevivÃªncia profissional.

ğŸ“ **Exemplo**
Quem estima mal:

* promete demais,
* entrega atrasado,
* perde confianÃ§a.

Quem estima melhor:

* negocia escopo,
* ajusta expectativas,
* sofre menos.

---

## ğŸ¯ ConclusÃ£o do CapÃ­tulo

### ğŸ“Œ â€œMantendo esses princÃ­pios bÃ¡sicos em mente...â€

O autor fecha dizendo:

* esses princÃ­pios nÃ£o sÃ£o mÃ¡gicos,
* mas **melhoram tudo**:

  * qualidade,
  * velocidade,
  * consistÃªncia.

E simâ€¦
Pode atÃ© parecer fÃ¡cil no papel.
DifÃ­cil Ã© aplicar **todo dia**, sob pressÃ£o ğŸ˜….

---

# âš ï¸ CapÃ­tulo 7 â€” Os Males da DuplicaÃ§Ã£o

## ğŸ–– IntroduÃ§Ã£o com Star Trek

### ğŸ“Œ â€œFornecer ao computador dois blocos de informaÃ§Ãµes contraditÃ³rios...â€

Aqui o autor comeÃ§a com uma metÃ¡fora genial:

ğŸ‘‰ Em Star Trek, o CapitÃ£o Kirk derrotava IAs dando **ordens contraditÃ³rias**.

No software, fazemos isso o tempo todo sem perceber:

* regra em um lugar,
* regra diferente em outro.

Resultado?
ğŸ’¥ sistema quebra.

---

## ğŸ“š O papel do programador

### ğŸ“Œ â€œComo programadores, coletamos, organizamos...â€

Nosso trabalho gira em torno de **informaÃ§Ã£o**:

* requisitos,
* regras,
* validaÃ§Ãµes,
* dados.

Essas informaÃ§Ãµes aparecem:

* na documentaÃ§Ã£o,
* no cÃ³digo,
* nos testes.

---

## ğŸ”„ O problema: tudo muda

### ğŸ“Œ â€œInfelizmente, as informaÃ§Ãµes nÃ£o sÃ£o estÃ¡veis...â€

Nada fica parado:

* cliente muda ideia,
* lei muda,
* algoritmo nÃ£o funciona,
* requisito evolui.

Por isso:
ğŸ‘‰ **manutenÃ§Ã£o nÃ£o Ã© exceÃ§Ã£o, Ã© regra**.

---

## ğŸ”§ ManutenÃ§Ã£o nÃ£o comeÃ§a no deploy

### ğŸ“Œ â€œA maioria das pessoas considera que a manutenÃ§Ã£o comeÃ§a quando...â€

Aqui o autor quebra um mito importante:

ğŸš« ManutenÃ§Ã£o **nÃ£o comeÃ§a depois do lanÃ§amento**
âœ… ManutenÃ§Ã£o comeÃ§a **no primeiro dia de desenvolvimento**

Toda vez que vocÃª:

* ajusta entendimento,
* muda uma funÃ§Ã£o,
* refatora algo,

ğŸ‘‰ vocÃª estÃ¡ fazendo manutenÃ§Ã£o.

---

## ğŸ’£ Onde a duplicaÃ§Ã£o vira um pesadelo

### ğŸ“Œ â€œQuando trabalhamos em manutenÃ§Ã£o...â€

Manter software significa:

* achar onde a informaÃ§Ã£o estÃ¡,
* alterar todas as representaÃ§Ãµes dela.

Se ela estiver duplicada:
ğŸ˜± vocÃª vai esquecer algum lugar.

---

## ğŸ§  PrincÃ­pio NSR â€” NÃ£o Se Repita

### ğŸ“Œ DefiniÃ§Ã£o

> **Cada bloco de informaÃ§Ã£o deve ter uma representaÃ§Ã£o oficial, exclusiva e sem ambiguidades dentro de um sistema.**

Ou seja:

* uma fonte da verdade,
* um lugar certo,
* zero cÃ³pias espalhadas.

---

### ğŸ“Œ Por que isso Ã© tÃ£o importante?

Se vocÃª duplica:

* nÃ£o Ã© *se* vai dar problema,
* Ã© *quando*.

---

## ğŸ” Tipos de duplicaÃ§Ã£o

### 1ï¸âƒ£ DuplicaÃ§Ã£o imposta

Os desenvolvedores acham que nÃ£o tÃªm escolha â€“ o sistema, linguagem ou ambiente forÃ§a.

### 2ï¸âƒ£ DuplicaÃ§Ã£o inadvertida

Os desenvolvedores nÃ£o percebem que estÃ£o duplicando informaÃ§Ãµes.

### 3ï¸âƒ£ DuplicaÃ§Ã£o impaciente

Os desenvolvedores ficam com preguiÃ§a e duplicam porque parece mais fÃ¡cil

### 4ï¸âƒ£ DuplicaÃ§Ã£o entre desenvolvedores

VÃ¡rias pessoas de uma equipe (ou de equipes diferentes) duplicam um bloco de informaÃ§Ãµes.

---

## ğŸ§© DuplicaÃ§Ã£o imposta

### ğŸ“Œ VÃ¡rias representaÃ§Ãµes da informaÃ§Ã£o

Exemplos comuns:

* frontend e backend,
* classe e tabela de banco,
* cÃ³digo e exemplo em documentaÃ§Ã£o.

ğŸ’¡ SoluÃ§Ã£o:

* geradores de cÃ³digo,
* metadados,
* automaÃ§Ã£o.

O segredo:
ğŸ‘‰ o processo precisa ser **automÃ¡tico e contÃ­nuo**.

---

### ğŸ“Œ DocumentaÃ§Ã£o no cÃ³digo

CÃ³digo bom:

* se explica sozinho.

ComentÃ¡rios devem explicar:

* **por quÃª**,
* nÃ£o **o quÃª**.

ComentÃ¡rio duplicando cÃ³digo:

* fica desatualizado,
* engana quem lÃª,
* Ã© pior que nenhum comentÃ¡rio.

---

### ğŸ“Œ DocumentaÃ§Ã£o e cÃ³digo

Quando doc e cÃ³digo dizem a mesma coisa:

* alguÃ©m vai esquecer de atualizar um deles.

ğŸ’¡ SoluÃ§Ã£o real usada:

* gerar testes a partir da documentaÃ§Ã£o.

Assim:

* mudou a doc â†’ testes mudam,
* inconsistÃªncia vira impossÃ­vel.

---

### ğŸ“Œ Problemas de linguagem

Algumas linguagens **forÃ§am duplicaÃ§Ã£o**:

* headers,
* interfaces,
* IDLs.

Aqui nÃ£o tem milagre.
A boa notÃ­cia:

* erro aparece rÃ¡pido (compilaÃ§Ã£o).

---

### ğŸ“Œ ComentÃ¡rios em headers e implementaÃ§Ã£o

Regra simples:

* header: o que o usuÃ¡rio precisa saber
* implementaÃ§Ã£o: como funciona por dentro

Duplicar comentÃ¡rio = trabalho dobrado.

--------------------------------------------------------------------------------------
## ğŸ” DuplicaÃ§Ã£o inadvertida (aquela que acontece â€œsem quererâ€)

Ã€s vezes, a duplicaÃ§Ã£o aparece nÃ£o por preguiÃ§a, mas porque o **projeto foi pensado de um jeito meio torto**.
NÃ£o foi maldade. Foi descuido mesmo.

Vamos imaginar um exemplo bem realista.

### ğŸšš Exemplo do mundo real: distribuiÃ§Ã£o e logÃ­stica

Suponha que estamos criando um sistema para uma empresa de distribuiÃ§Ã£o.

Durante a anÃ¡lise, percebemos que um **caminhÃ£o** tem:

* um tipo (baÃº, carreta, frigorÃ­fico),
* uma placa,
* e um motorista.

AtÃ© aqui, tudo parece normal.

Agora, tambÃ©m descobrimos que uma **rota de distribuiÃ§Ã£o** Ã© composta por:

* o trajeto em si,
* um caminhÃ£o,
* e um motorista.

Pronto. Parece simples, nÃ©? EntÃ£o seguimos em frente e criamos as classes com base nisso.

### ğŸ¤’ E quando o mundo real resolve atrapalhar?

Agora imagine o seguinte cenÃ¡rio, super comum no dia a dia:

A Sally, que dirige um dos caminhÃµes, acorda doente.
Ela nÃ£o pode trabalhar hoje.

Pergunta simples:
ğŸ‘‰ **onde vocÃª troca o motorista no sistema?**

* Na classe **CaminhÃ£o**?
* Na classe **RotaDeDistribuiÃ§Ã£o**?

O problema Ã© que **as duas tÃªm um motorista**.

Se vocÃª trocar em um lugar e esquecer do outro, o sistema fica inconsistente.
Um lugar diz que o motorista Ã© JoÃ£o, o outro diz que ainda Ã© Sally.

ğŸ’¥ BagunÃ§a criada.

### ğŸš¨ O problema real aqui

Esse tipo de duplicaÃ§Ã£o Ã© **ruim**, porque:

* gera confusÃ£o,
* aumenta a chance de erro,
* e transforma qualquer mudanÃ§a simples em dor de cabeÃ§a.

A soluÃ§Ã£o Ã© **normalizar os dados**, ou seja, alinhar o cÃ³digo com o **modelo real do negÃ³cio**.

FaÃ§a perguntas importantes:

* Um caminhÃ£o *realmente* â€œtemâ€ um motorista fixo?
* Ou o motorista pertence Ã  rota?
* Ou talvez o motorista seja alocado temporariamente?

Talvez a melhor soluÃ§Ã£o seja criar **um terceiro objeto**, algo como:

> AlocaÃ§Ã£oDeMotorista

Esse objeto poderia reunir:

* motorista,
* caminhÃ£o,
* rota,
* perÃ­odo.

NÃ£o importa qual soluÃ§Ã£o vocÃª escolha â€” o importante Ã© **nÃ£o manter dados duplicados e desconectados da realidade**.

---

## ğŸ” Um tipo de duplicaÃ§Ã£o mais sutil (e mais perigoso)

Agora vamos falar de um tipo de duplicaÃ§Ã£o que **engana atÃ© desenvolvedores experientes**.

Ela acontece quando temos **dados que dependem uns dos outros**.

### ğŸ“ Exemplo: uma linha geomÃ©trica

Veja esta classe:

```cpp
class Line {
 public:
  Point start;
  Point end;
  double length;
};
```

Ã€ primeira vista, parece perfeita.

Uma linha:

* tem um ponto inicial,
* tem um ponto final,
* e tem um comprimento.

Tudo certo, nÃ©?

ğŸ˜¬ Nem tanto.

### ğŸ§  Onde estÃ¡ a duplicaÃ§Ã£o?

O comprimento **nÃ£o Ã© um dado independente**.
Ele Ã© **calculado** a partir dos pontos inicial e final.

Se vocÃª mudar:

* o ponto inicial **ou**
* o ponto final,

o comprimento muda automaticamente.

Ou seja:
ğŸ“Œ o `length` estÃ¡ duplicando uma informaÃ§Ã£o que jÃ¡ existe nos outros dois atributos.

### âŒ O perigo disso

Agora imagine que alguÃ©m altera o ponto inicial, mas esquece de atualizar o comprimento.

Pronto.
O objeto virou uma mentira ambulante.

---

## âœ… A soluÃ§Ã£o correta: calcular em vez de armazenar

A melhor saÃ­da Ã© **nÃ£o armazenar o comprimento**, mas calculÃ¡-lo sempre que alguÃ©m pedir.

Assim:

```cpp
class Line {
 public:
  Point start;
  Point end;
  double length() { return start.distanceTo(end); }
};
```

Agora:

* nÃ£o existe risco de inconsistÃªncia,
* nÃ£o hÃ¡ duplicaÃ§Ã£o,
* e o cÃ³digo reflete a realidade matemÃ¡tica.

---

## âš¡ â€œMas e o desempenho?â€

Mais pra frente no projeto, vocÃª pode perceber que calcular esse comprimento toda hora custa caro.

Talvez:

* a operaÃ§Ã£o seja pesada,
* seja chamada milhares de vezes,
* ou impacte a performance.

Nesse caso, vocÃª **pode quebrar a regra**, mas **com cuidado**.

### ğŸ§  A regra de ouro

Se vocÃª for violar o princÃ­pio *NÃ£o Se Repita (NSR)*:

* faÃ§a isso **apenas internamente**,
* sem deixar o problema vazar para fora da classe.

### ğŸ§° Exemplo com cache

```cpp
class Line {
private:
  bool changed;
  double length;
  Point start;
  Point end;

public:
  void setStart(Point p) { start = p; changed = true; }
  void setEnd(Point p) { end = p; changed = true; }

  Point getStart(void){ return start; }
  Point getEnd(void){ return end; }

  double getLength() {
    if (changed) {
      length = start.distanceTo(end);
      changed = false;
    }
    return length;
  }
};
```

Aqui acontece o seguinte:

* sempre que os pontos mudam, marcamos como â€œalteradoâ€,
* o comprimento sÃ³ Ã© recalculado quando alguÃ©m pede,
* depois disso, fica em cache.

Resultado:
âœ” desempenho melhor
âœ” sem inconsistÃªncia
âœ” duplicaÃ§Ã£o controlada

---

## ğŸ” Por que usar getters e setters?

Esse exemplo mostra algo muito importante em linguagens orientadas a objetos como **Java e C++**.

Sempre que possÃ­vel:
ğŸ‘‰ **use mÃ©todos para acessar e alterar atributos**, em vez de mexer neles diretamente.

Por quÃª?

* facilita adicionar cache,
* validaÃ§Ã£o,
* logs,
* regras extras no futuro,

sem quebrar quem usa a classe.

Isso segue o **PrincÃ­pio do Acesso Uniforme**, que basicamente diz:

> NÃ£o importa se o dado vem de um cÃ¡lculo ou de um armazenamento â€” o uso deve ser o mesmo.

----------------------------------------------------------------------------------

## â±ï¸ DuplicaÃ§Ã£o impaciente (a famosa â€œgambiarra do prazoâ€)

Todo projeto sofre pressÃ£o de tempo.

E quando o prazo aperta, a tentaÃ§Ã£o aparece:

* â€œVou sÃ³ copiar esse mÃ©todo e adaptarâ€¦â€
* â€œVou usar esse nÃºmero mÃ¡gico aqui mesmoâ€¦â€
* â€œDepois eu arrumoâ€¦â€

Spoiler:
ğŸ‘‰ **depois nunca chega**.

### ğŸ˜¬ Exemplos clÃ¡ssicos

* Copiar um mÃ©todo parecido em vez de generalizar.
* Espalhar o mesmo nÃºmero literal em vÃ¡rios arquivos.
* Copiar cÃ³digo inteiro de outra biblioteca â€œsÃ³ pra agilizarâ€.

Na hora parece rÃ¡pido.
Depois vira um inferno.

### ğŸ’£ O famoso caso do bug do milÃªnio (Y2K)

Muitos problemas do Y2K aconteceram porque:

* datas foram codificadas â€œno improvisoâ€,
* campos nÃ£o eram parametrizados,
* nÃ£o existia uma biblioteca central de datas.

Tudo funcionavaâ€¦ atÃ© o mundo virar o calendÃ¡rio.

---

## ğŸ§˜ Disciplina agora = menos dor depois

DuplicaÃ§Ã£o impaciente Ã© fÃ¡cil de identificar.
O difÃ­cil Ã© **ter disciplina para evitÃ¡-la**.

Ã‰ o clÃ¡ssico:

> sofrer um pouquinho agora para nÃ£o sofrer muito depois.

-------------------------------------------------------------------------------------

## ğŸ‘¥ DuplicaÃ§Ã£o entre desenvolvedores (a mais traiÃ§oeira)

Esse Ã© o tipo mais difÃ­cil de perceber.

Aqui nÃ£o Ã© uma pessoa copiando cÃ³digo dela mesma.
SÃ£o **pessoas diferentes resolvendo o mesmo problema, cada uma do seu jeito**.

### ğŸ›ï¸ Exemplo real (e assustador)

Um estado dos EUA fez uma auditoria para o Y2K.

Resultado:

* mais de **10.000 programas**,
* cada um com sua **prÃ³pria validaÃ§Ã£o de nÃºmero de seguro social**.

Tudo duplicado.
Tudo diferente.
Tudo difÃ­cil de manter.

---

## ğŸ§­ Como evitar isso?

Em nÃ­vel geral:

* projeto bem definido,
* lideranÃ§a tÃ©cnica forte,
* responsabilidades claras.

Mas no dia a dia do cÃ³digo, isso nÃ£o basta.

### ğŸ—£ï¸ ComunicaÃ§Ã£o Ã© a chave

Algumas prÃ¡ticas que ajudam muito:

* fÃ³runs internos de discussÃ£o,
* grupos para troca de ideias,
* histÃ³rico acessÃ­vel de decisÃµes tÃ©cnicas.

Antigamente era Usenet.
Hoje pode ser Slack, Teams, GitHub Discussions, o que for.

### ğŸ“š O â€œbibliotecÃ¡rioâ€ do projeto

Uma Ã³tima ideia Ã© ter alguÃ©m responsÃ¡vel por:

* organizar cÃ³digo reutilizÃ¡vel,
* divulgar soluÃ§Ãµes existentes,
* facilitar a troca de conhecimento.

AlÃ©m disso:

* tenha um local central para utilitÃ¡rios,
* leia cÃ³digo de outras pessoas,
* participe de revisÃµes.

Isso nÃ£o Ã© bisbilhotar.
Ã‰ aprender â€” e ensinar.

---

## ğŸ’¡ DICA 12 â€” Facilite a reutilizaÃ§Ã£o

O objetivo final Ã© simples:

ğŸ‘‰ **tornar mais fÃ¡cil reutilizar do que recriar**.

Se reutilizar dÃ¡ trabalho:

* ninguÃ©m vai fazer.

E se ninguÃ©m reutiliza:

* a duplicaÃ§Ã£o cresce,
* os bugs se multiplicam,
* e o projeto envelhece mal.

Crie um ambiente onde:

* soluÃ§Ãµes existentes sÃ£o fÃ¡ceis de encontrar,
* reutilizar Ã© o caminho natural,
* e duplicar vira exceÃ§Ã£o, nÃ£o regra.
